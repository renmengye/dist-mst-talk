% !TEX root=../presentation_1.tex
\section{Method}

\begin{frame}
\frametitle{A Simple Deterministic Algorithm [Elk17]}
\begin{itemize}
    \item Idea: use better BFS broadcasting structure.
    \item Suppose we have an $(n/k,O(k))$-MST forest $\mathcal{F}$ using GHS. 
    \item At most $n/k$ fragments, each with diameter $O(k)$.
    \item $O(k \log^*n)$ rounds with $O(m + k \log n)$ messages.
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{A Simple Deterministic Algorithm [Elk17]}
\begin{itemize}
    \item Build an auxillary BFS tree $\tau$.
    \item $O(D)$ time and $O(m)$ messages.
    \item Each node compute the BFS interval.
    \begin{itemize}
        \item One convergecast to count the number of leaves under each node.
        \item One broadcast to assign interval.
        \item $O(D)$ time and $O(n)$ messages.
    \end{itemize}
    \item Interval is computed so that we know how to route messages from the root to any base fragment F
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{A Simple Deterministic Algorithm [Elk17]}
\begin{itemize}
    \item Finally conduct a pipelined convergecast and the root learns the intervals of all the base fragments. Sends messages of the maximum interval of each fragment.
    \item Takes $O(D+\frac{n}{k})$ and $O(D \cdot \frac{n}{k})$ messages. (Need to aggregate messages of one fragment at a time.)
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{A Simple Deterministic Algorithm [Elk17]}
\begin{itemize}
    \item To send the fragment ID, it takes $O(1)$ time and $O(m)$ messages.
    \item To convergecast the $\frac{n}{k}$ fragment identities, it takes $O(D+\frac{n}{k})$ time and $O(D \cdot\frac{n}{k})$ messages.
    \item Now assume that each vertex $v$ knows its base fragment ID, and also the base fragments ID of its neighbors, we can compute MWOE locally, and send the edge to the root of the fragment
    \item Now suppose $D \le \sqrt{n}$, and we select $k=\sqrt{n}$.
    \item $O(k)=O(\sqrt{n})$ rounds and $O(n)$ messages.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{A Simple Deterministic Algorithm [Elk17]}
\begin{itemize}
    \item Perform a pipelined convergecast to the root.
    \item $O(D+\frac{n}{k})$ rounds and $O(D \cdot \frac{n}{k})$ messages.
    \item Then the root locally computes the maximal matching, and tells each fragment which one to merge with.
    \item Sends message $<F,F'>$ through pipelined broadcast, to tell $F$ to merge with $F'$.
    \item The node that receives merge message, changes the fragment ID.
    \item $O(D+\frac{n}{k})$ rounds and $O(D \cdot \frac{n}{k})$ messages.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{A Simple Deterministic Algorithm [Elk17]}
\begin{itemize}
    \item Finally, every vertex need to notify its neighbor about the change in fragment identity. This takes $O(1)$ time and $O(m)$ messages.
    \item In total, the overall time complexity is $O(D+\frac{n}{k}) + O(k\log^* n) + O((D + k + \frac{n}{k})\log n) = O(\sqrt{n}\log n)$.
    \item The overall the message complexity is $O(E \log n + n\log n \cdot \log^* n)$.
\end{itemize}
\end{frame}

\begin{frame}
\frametitle{A Simple Deterministic Algorithm [Elk17]}
\begin{itemize}
    \item If $D > \sqrt{n}$, then let $k=D$.
    \item $O(D+\frac{n}{k}) + O(k\log^* n) + O((D + k + \frac{n}{k})\log n) = O(D\log n)$ rounds
    \item The number of messages is the same as before.
    \item Combining two cases, $O((D + \sqrt{n})\log n)$ rounds and $O(E \log n + n\log n \cdot \log^* n)$ messages.
\end{itemize}
\end{frame}


\begin{frame}
\frametitle{Conclusion}
\begin{itemize}
    \item Near optimal time and message complexities.
    \item A fully deterministic algorithm.
\end{itemize}

\input{sections/table}
\end{frame}
